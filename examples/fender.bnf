sep ::= [ \n\t]+
break ::= sep? ((";" | "\n") sep?)+

root ::= break? (statement break?)*
statement ::= assignment | expr | returnStatement
returnStatement ::= "return" (sep expr)?
assignment ::= "$"? name sep? "=" sep? expr

binaryOperator ::= "||" | "&&" | "==" | "<=" | ">=" | [-+*/^<>]
unaryOperator ::= [-!]

expr ::= term (sep? binaryOperator sep? term)*
enclosedExpr ::= "(" sep? expr sep? ")"
term ::= (unaryOperator sep?)? value sep? tailOperationChain?
lambdaParameter ::= "$"
value ::= enclosedExpr | name | literal | lambdaParameter

alpha ::= [a-z] | [A-Z]
alphanum ::= [a-z] | [A-Z] | [0-9]
name ::= ("_" | alpha) alphanum*

literal ::= float | int | boolean | string | list | function
int ::= "-"? [0-9]+
list ::= "[" sep? (expr (sep? "," sep? expr)*)? sep? "]"
float ::= ("-"? [0-9]+)? "." [0-9]+
string ::= "\"" (escapeSequence | [^"])* "\""
escapeSequence ::= "\\" [^]
boolean ::= "true" | "false"

invoke ::= invokeArgs | functionBody
invokeArgs ::= "(" sep? (expr sep? ("," sep? expr)*)? sep? ")"

functionArg ::= name (sep? ":" sep? name)?
functionBody ::= "{" break? (statement break)* statement? break? "}"
functionArgs ::= "(" sep? (functionArg sep? ("," sep? functionArg)*)? sep? ")"
function ::= functionArgs? sep? functionBody

receiverCall ::= "." sep? name sep? invoke
index ::= "[" expr "]"
tailOperation ::= receiverCall | index
tailOperationChain ::= tailOperation (sep? tailOperation)*