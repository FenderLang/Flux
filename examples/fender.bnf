sep ::= [ \t]+
break ::= sep? ((";" | "\n") sep?)+
lineBreak ::= sep? ("\n" sep?)+
lineSep ::= lineBreak | sep
comment ::= "#" [^\n]*

root ::= break? (statement break)* statement? break?
statement ::= (declaration | assignment | expr | returnStatement) comment?
return ::= "pass" | "return"
returnStatement ::= return (lineSep expr)?
declaration ::= "$" sep? name sep? "=" lineSep? expr
assignment ::= expr sep? [-+/*]? "=" lineSep? expr

binaryOperator ::= "||" | "&&" | "==" | "<=" | ">=" | [-+*/^<>]
unaryOperator ::= [-!]

expr ::= term (lineSep? binaryOperator lineSep? term)*
enclosedExpr ::= "(" lineSep? expr lineSep? ")"
term ::= (unaryOperator sep?)* value sep? tailOperationChain?
lambdaParameter ::= "$"
value ::= literal | enclosedExpr | name | lambdaParameter

alpha ::= [a-z] | [A-Z]
alphanum ::= [a-z] | [A-Z] | [0-9]
name ::= ("_" | alpha) alphanum*

literal ::= float | int | boolean | string | list | function
int ::= "-"? [0-9]+
list ::= "[" lineSep? (expr (lineSep? "," lineSep? expr)*)? lineSep? "]"
float ::= ("-"? [0-9]+)? "." [0-9]+
string ::= "\"" (escapeSequence | [^"])* "\""
escapeSequence ::= "\\" [^]
boolean ::= "true" | "false"

invoke ::= invokeArgs | functionBody
invokeArgs ::= "(" lineSep? (expr lineSep? ("," sep? lineSep)*)? sep? ")"

functionArg ::= name (lineSep? ":" lineSep? name)?
functionBody ::= "{" break? (statement break)* statement? break? "}"
functionArgs ::= "(" lineSep? (functionArg lineSep? ("," lineSep? functionArg)*)? lineSep? ")"
function ::= functionArgs? lineSep? functionBody

receiverCall ::= "." lineSep? name sep? invoke
index ::= "[" expr "]"
tailOperation ::= invoke | receiverCall | index
tailOperationChain ::= tailOperation (lineSep? tailOperation)*