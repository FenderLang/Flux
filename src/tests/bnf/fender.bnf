sep ::= [ \t]+
newLine ::= "\r"? "\n"
break ::= sep? ((";" | comment? newLine) sep?)+
lineBreak ::= sep? comment? (newLine sep?)+
lineSep ::= lineBreak | sep
comment ::= "#" [^\n]*

root ::= break? (statement break)* statement? break?
statement ::= (import | functionDeclaration | structDeclaration | declaration | assignment | returnStatement | expr) sep? comment?
return ::= "pass" | "return" ("@" name)?
returnStatement ::= return (lineSep expr)?
declaration ::= "$" sep? name sep? "=" lineSep? expr
assignment ::= expr sep? [-+/*]? "=" lineSep? expr
importPath ::= [^: \t\n]+
import ::= "import" sep ("*" sep?)? importPath (":" name)? (sep importAs)?
importAs ::= "as" sep name

binaryOperator ::= "||" | "&&" | "==" | "<=" | ">=" | ".." "="? | [-+*/^<>]
unaryOperator ::= [-!]

label ::= "`" name lineSep
expr!4 ::= label? term (lineSep? binaryOperator lineSep? term)*
enclosedExpr ::= "(" lineSep? expr lineSep? ")"
term ::= (unaryOperator sep?)* value sep? tailOperationChain?
lambdaParameter ::= "$"
value!10 ::= literal | enclosedExpr | name | lambdaParameter

alpha ::= [a-z] | [A-Z]
alphanum ::= [a-z] | [A-Z] | [0-9] | "_"
name ::= ("_" | alpha) alphanum*

literal ::= float | int | boolean | string | list | map | closure
int ::= "-"? [0-9]+
list ::= "[" lineSep? (expr (lineSep? "," lineSep? expr)*)? lineSep? "]"
mapEntry ::= expr lineSep? ":" lineSep? expr
emptyMap ::= "[" lineSep? ":" lineSep? "]"
map ::= emptyMap | "[" lineSep? mapEntry (lineSep? "," lineSep? mapEntry)* lineSep? "]"
float ::= "-"? ([0-9]+)? "." [0-9]+
string ::= "\"" (escapeSequence | [^"])* "\""
escapeSequence ::= "\\" [^]
boolean ::= "true" | "false"

invoke ::= invokeArgs | codeBody
invokeArgs ::= "(" lineSep? (expr lineSep? ("," lineSep? expr)*)? sep? ")"

structDeclaration ::= "struct" sep? name lineSep? "{" lineSep? (arg (lineSep? "," lineSep? arg)*)? lineSep? "}"

arg ::= name (sep? typeAnnotation)?
typeAnnotation ::= ":" lineSep? name
codeBody ::= "{" break? (statement break)* statement? break? "}"
args ::= "(" lineSep? (arg lineSep? ("," lineSep? arg)*)? lineSep? ")"
closure ::= args? lineSep? codeBody
functionDeclaration ::= "fn" sep? name lineSep? args lineSep? ("=" lineSep? expr | codeBody)

fieldAccess ::= ":" lineSep? name
receiverCall ::= "." lineSep? name sep? invoke
index ::= "[" expr "]"
tailOperation ::= invoke | receiverCall | index | fieldAccess
tailOperationChain ::= tailOperation (lineSep? tailOperation)*